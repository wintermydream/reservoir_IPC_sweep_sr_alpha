"""
Plot stacked bar of degree-1/3/5/7 memory capacities vs spectral radius
for two different input scaling values (alpha = 0.8, 1.0).

The script expects cached capacity files generated by
`debug_d7_capacity_vs_sr.py` naming convention:
    d1_d3_d5_d7_capacity_vs_sr_N{num_nodes}_al{alpha:.3f}_om{omega:.3f}.npz
If a required file is missing, the corresponding bar group is skipped with a
warning.

Usage:  python plot_d7_capacity_vs_sr.py  # default parameters

"""
from __future__ import annotations

from pathlib import Path
from typing import List, Dict

import matplotlib.pyplot as plt
import numpy as np

# -----------------------------------------------------------------------------
# Configuration – adjust here if necessary
# -----------------------------------------------------------------------------
NUM_NODES: int = 100
OMEGA: float = 1.0
ALPHAS: List[float] = [0.6, 0.8, 1.0]  # bars per sr group
# If data uses different grid, we'll fetch dynamically
SR_VALUES = None  # will fill later
DATA_DIR = Path("debug_capacity_data")
OUT_PNG = "capacity_vs_sr_stacked_bar.png"

# Bar appearance
DEGREE_COLORS = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728"]  # d1-d7
HATCHES = ["////", "\\\\", ".."]  # patterns for alpha groups

# -----------------------------------------------------------------------------
# Helper to load capacity arrays
# -----------------------------------------------------------------------------

def load_capacity_for_alpha(alpha: float):
    """Return dict with keys 'sr', 'd1', 'd3', 'd5', 'd7' (np.ndarray of len SR_VALUES)."""
    npz_file = DATA_DIR / (
        f"d1_d3_d5_d7_capacity_vs_sr_N{NUM_NODES}_al{alpha:.3f}_om{OMEGA:.3f}.npz"
    )
    if not npz_file.exists():
        print(f"[Warning] missing cache {npz_file.name}, skip alpha={alpha}")
        return None
    data = np.load(npz_file)
    return {
        "sr": data["sr_values"],
        "d1": data["d1_scores"],
        "d3": data["d3_scores"],
        "d5": data["d5_scores"],
        "d7": data["d7_scores"],
    }


# -----------------------------------------------------------------------------
# Main plotting routine
# -----------------------------------------------------------------------------

def plot_stacked_bar_capacity_vs_sr() -> None:
    # Load all alpha data first to know sr grid
    alpha_data = []
    for a in ALPHAS:
        d = load_capacity_for_alpha(a)
        if d is not None:
            alpha_data.append((a, d))
    if not alpha_data:
        print("[Error] No capacity data found for any alpha. Abort plot.")
        return

    global SR_VALUES
    SR_VALUES = alpha_data[0][1]["sr"]  # assume same for all

    fig, ax = plt.subplots(figsize=(15, 6))

    n_alpha = len(alpha_data)
    # Nature-style: leave small intra-sr gap
    group_gap = 0.05  # fraction left empty at right of group
    bar_width = (0.8 - group_gap) / n_alpha

    x = np.arange(len(SR_VALUES))

    legends_handles = []

    legends_handles = []
    for j, (alpha, cap_dict) in enumerate(alpha_data):

        # Bars for every sr
        bar_positions = x - 0.4 + j * bar_width + (j * group_gap / n_alpha)

        # Bottom tracker
        bottom = np.zeros_like(SR_VALUES, dtype=float)

        for k, (deg_key, color) in enumerate(zip(["d1", "d3", "d5", "d7"], DEGREE_COLORS)):
            values = cap_dict[deg_key]
            bars = ax.bar(
                bar_positions,
                values,
                bar_width,
                bottom=bottom,
                color=color,
                edgecolor="black",
                linewidth=0.6,
                alpha=0.8,
                hatch=HATCHES[j % len(HATCHES)],
            )
            if k == 0:  # only need one handle per alpha
                legends_handles.append(bars)
            bottom += values

    # Axis settings
    ax.set_xlabel("Spectral radius (sr)")
    ax.set_ylabel("Capacity")
    ax.set_title("Degree 1/3/5/7 Capacity vs Spectral Radius (alpha=0.8 & 1.0)")
    ax.set_xticks(x)
    ax.set_xticklabels([f"{sr:.1f}" for sr in SR_VALUES])
    ax.grid(True, linestyle="--", alpha=0.6)

    # Legend: alpha groups only
    ax.legend(legends_handles, [f"alpha={a}" for a, _ in alpha_data], title="Input scaling", fontsize=9)

    fig.tight_layout()

    # ------------------------- line subplots ------------------------------
    # Four subplots for degree 1,3,5,7; each shows three alpha curves
    fig2, axes2 = plt.subplots(1, 4, figsize=(18, 4), sharey=False)
    deg_keys = ["d1", "d3", "d5", "d7"]
    deg_titles = ["Degree 1", "Degree 3", "Degree 5", "Degree 7"]
    markers = ['o-', 's--', 'd:', '^-']

    for idx, (deg_key, title) in enumerate(zip(deg_keys, deg_titles)):
        axd = axes2[idx]
        for j, (alpha, cap_dict) in enumerate(alpha_data):
            axd.plot(
                SR_VALUES,
                cap_dict[deg_key],
                markers[j % len(markers)],
                label=f"alpha={alpha}",
                markersize=4,
            )
        axd.set_title(title)
        axd.set_xlabel("sr")
        axd.set_ylabel("Capacity")
        axd.grid(True, linestyle="--", alpha=0.6)
        axd.legend(fontsize=8)

    fig2.suptitle("Capacity vs Spectral Radius for α = 0.6, 0.8, 1.0", fontsize=14)
    fig2.tight_layout(rect=[0, 0, 1, 0.93])

    plt.show()


if __name__ == "__main__":
    plot_stacked_bar_capacity_vs_sr()
